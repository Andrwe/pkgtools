#!/bin/bash
# pkgfile -- search the arch repo to see what package owns a file


###
# You can change these values in the config file
##
FILELIST_DIR="/usr/share/pkgtools/lists"
RATELIMIT='100k' # Argument to wget's --limit-rate flag

if [ -r /usr/share/pkgtools/functions ]; then
        source /usr/share/pkgtools/functions
else
        printf "Unable to source function file!\n" >&2
        exit 1
fi

###
# You should not change below this point
##
VERBOSE=0
DEBUG=0
REPOS=(core extra community unstable)


if [ -r /etc/pkgtools/pkgfile.conf ]; then
        source /etc/pkgtools/pkgfile.conf
fi
if [ -r "${HOME}/.pkgtools/pkgfile.conf" ]; then
        source "${HOME}/.pkgtools/pkgfile.conf"
fi
MYVERSION=4.0
SEARCHTARGET=
ACTIONS=()
PROGNAME="$(basename $0)"

# not() -- toggle a 0/1 {{{
not () {
        if [ "$1" -eq 0 ]; then
                echo 1
        else
                echo 0
        fi
}
# }}}

# usage() {{{
usage () {
        msg "%s version %s -- Find which package owns a file\n" "$PROGNAME" $MYVERSION
        msg "Usage: %s [OPTIONS] filename\n" "$PROGNAME"
        msg "  -h --help       - Print this help\n"
        msg "  -d --debug      - Enable debug output\n"
        msg "  -u --update     - Update to the latest filelist\n"
        msg "                    This requires write permission for\n"
        msg "                    %s\n" $FILELIST_DIR
        msg "  -v --verbose    - Enable verbose output:\n"
        msg "                    List the exact filename found,\n"
        msg "                    instead of just the package name\n"
        msg "  --limit-rate    - This argument is used with --update\n"
        msg "                    It is passed directly to wget\n"
        msg "  -r --regex      - Search for a regex instead of a filename\n"
        msg "  -l --list       - List files similar to pacman -Ql\n"
        quit 0
}
# }}}

# update() -- update the package file list {{{
update () {
        for repo in ${REPOS[@]}; do
                [ "$DEBUG" -eq 1 ] && set -x
                eval mirror="$(grep -v '^ *#' /etc/pacman.d/mirrorlist | grep -v '^ *$' | head -n 1 | cut -d ' ' -f 3)"
                repofile="${repo}.files.tar.gz"
                filelist="${mirror}/${repofile}"
                if [ ! -d "$FILELIST_DIR" ]; then
                        warn "%s does not exist -- creating" $FILELIST_DIR
                        mkdir -p "$FILELIST_DIR" || die 1 "Could not create %s\n" $FILELIST_DIR
                fi
                if [ ! -w "$FILELIST_DIR" ];then
                        die 1 "No write permission to %s, try somewhere else\n" "$FILELIST_DIR"
                fi
                cd "$FILELIST_DIR" || die 1 "Unable to change directory to %s\n" $FILELIST_DIR
                rm -f "$repofile"
                if [ "$VERBOSE" -eq 1 ]; then
                        msg "Using mirror %s... " $mirror
                fi
                msg "Updating %s file list... " $repo
                wget -q  --limit-rate="$RATELIMIT" "$filelist" || (warn "Could not retrieve %s\n" $filelist; continue)
                msg "Extracting file list... " $repo
                mkdir -p "$repo" || (warn "Could not create directory for %s\n" $repo; continue)
                tar zxf "$repofile" -C "$repo" 2> /dev/null || (warn "Unable to extract %s\n" $repofile; continue)
                msg "Done\n"
                [ "$DEBUG" -eq 1 ] && set +x
        done
        return 0

}
# }}}

# search() -- find which package owns a file {{{
search () {
        [ "$DEBUG" -eq 1 ] && set -x
        if [ "regex" = "$action" ]; then
                local fname="$1"
        else
                local fname="$(echo $1 | sed 's|^/|^|;s|^\([^^]\)|/\1|')$"; shift
                # Change a leading / to ^.
                # Change a leading non-^ character to '/$char;
                # This will fix grep's regex to prevent false positives
        fi
        [ "$DEBUG" -eq 1 ] && echo "'$fname'"

        cd "$FILELIST_DIR" || die 1 "Unable to change directory to %s\n" $FILELIST_DIR
        if echo * | grep -q '^\*$'; then
                die 1 "%s appears to be empty! Did you run %s --update?\n" "$FILELIST_DIR" "$PROGNAME"
        fi

        if [ "$VERBOSE" -eq 0 ]; then
                local sedstring='s#-[0-9.a-z_]*-[0-9.]*/files:.*##'
        else
                local sedstring='s#-[0-9.a-z_]*-[0-9.]*/files:.*# : #' 
        fi

        grep -R "$fname" */* | sed "$sedstring" | uniq

        [ "$DEBUG" -eq 1 ] && set -x
        quit 0
}
# }}}

# listfiles() {{{
listfiles () {
        local pkg="$1"
        local FOUNDFILE=0
        cd "$FILELIST_DIR" || die 1 "Unable to change directory to %s\n" $FILELIST_DIR
        if echo * | grep -q '^\*$'; then
                die 1 "%s appears to be empty! Did you run %s --update?\n" "$FILELIST_DIR" "$PROGNAME"
        fi
        for repo in ${REPOS[@]}; do
                [ "$DEBUG" -eq 1 ] && set -x
                local findarg="$repo/$pkg-[^-]+-[^-]+$"
                local findresult="$(\
                find "$repo" -type d -regex "$findarg" | while read line; do
                        filelist="$line/files"
                        sed -n "1d;s|^|$pkg /|p" "$filelist" # Give it output like pacman -Ql
                done)"
                if [ -n "$findresult" ]; then
                        FOUNDFILE=1
                        echo "$findresult"
                fi
                [ "$DEBUG" -eq 1 ] && set -x
        done
        if [ "$FOUNDFILE" -eq 0 ]; then
                msg "Package '%s' not found\n" "$pkg"
        fi
}
# }}}

if [ -z "$1" ]; then
        usage
fi

while [ $# -gt 0 ]; do
        case "$1" in
                -h|--help)
                        usage
                        ;;
                -u|--update)
                        ACTIONS=(update ${ACTIONS[@]})
                        ;;
                -v|--verbose)
                        VERBOSE=$(not $VERBOSE)
                        ;;
                -d|--debug)
                        DEBUG=$(not $DEBUG)
                        ;;
                --ratelimit)
                        RATELIMIT="$1"
                        ;;
                -r|--regex)
                        if [ -z "$2" ]; then
                                die 1 "%s %s option requires an argument!\n" "$PROGNAME" "$1"
                        fi
                        ACTIONS=(${ACTIONS[@]} regex)
                        SEARCHTARGET="$2"; shift
                        ;;
                -l|--list)
                        if [ -z "$2" ]; then
                                die 1 "%s %s option requires an argument!\n" "$PROGNAME" "$1"
                        fi
                        ACTIONS=(${ACTIONS[@]} list)
                        SEARCHTARGET="$2"; shift
                        ;;
                -*)
                        die 1 "Unrecognized option %s\n" "$1"
                        ;;
                *)
                        ACTIONS=(${ACTIONS[@]} search)
                        SEARCHTARGET="$1"
                        ;;
        esac
        shift
done

for action in "${ACTIONS[@]}"; do
        case $action in
                update)
                        update
                        ;;
                search|regex)
                        search "$SEARCHTARGET"
                        ;;
                list)
                        listfiles "$SEARCHTARGET"
                        ;;
                *)
                        die 1 "Invalid \$ACTIONS item '%s' -- This should never happen!\n" "$action"
                        ;;
        esac
done

quit 0
# vim: set ts=8 fdm=marker et :
